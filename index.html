<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Trello → PDF Export</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
    background: #0f0f0f;
    color: #e8e8e8;
    min-height: 100vh;
    padding: 20px;
  }
  .container { max-width: 520px; margin: 0 auto; padding-top: 40px; }
  h1 { font-size: 1.6rem; font-weight: 700; margin-bottom: 6px; letter-spacing: -0.5px; }
  .subtitle { color: #888; font-size: 0.9rem; margin-bottom: 32px; }
  .field { margin-bottom: 20px; }
  label {
    display: block; font-size: 0.8rem; font-weight: 600;
    text-transform: uppercase; letter-spacing: 0.5px; color: #888; margin-bottom: 8px;
  }
  select, input {
    width: 100%; padding: 12px 14px; background: #1a1a1a;
    border: 1px solid #333; border-radius: 8px; color: #e8e8e8;
    font-family: inherit; font-size: 0.95rem; outline: none;
    transition: border-color 0.2s; -webkit-appearance: none; appearance: none;
  }
  select { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23888' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 14px center; padding-right: 36px; }
  select:focus, input:focus { border-color: #4c9aff; }
  select:disabled { opacity: 0.4; cursor: not-allowed; }
  .btn {
    width: 100%; padding: 14px; background: #4c9aff; color: #fff;
    border: none; border-radius: 8px; font-family: inherit;
    font-size: 1rem; font-weight: 600; cursor: pointer;
    transition: background 0.2s, transform 0.1s; margin-top: 8px;
  }
  .btn:hover { background: #6bb0ff; }
  .btn:active { transform: scale(0.98); }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; background: #333; }
  .btn-secondary { background: #333; margin-bottom: 0; }
  .btn-secondary:hover { background: #444; }
  .status { margin-top: 16px; padding: 12px 14px; border-radius: 8px; font-size: 0.85rem; display: none; }
  .status.info { display: block; background: #242424; color: #888; }
  .status.success { display: block; background: #1b3a1b; color: #4caf50; }
  .status.error { display: block; background: #3a1b1b; color: #ef5350; }
  .progress { margin-top: 16px; display: none; }
  .progress.visible { display: block; }
  .progress-bar { height: 4px; background: #242424; border-radius: 2px; overflow: hidden; }
  .progress-fill { height: 100%; background: #4c9aff; border-radius: 2px; transition: width 0.3s ease; width: 0%; }
  .progress-text { font-size: 0.8rem; color: #888; margin-top: 6px; }
  .settings-toggle { display: inline-block; font-size: 0.8rem; color: #4c9aff; cursor: pointer; margin-bottom: 16px; user-select: none; }
  .settings-toggle:hover { color: #6bb0ff; }
  .settings-panel { display: none; background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 16px; margin-bottom: 20px; }
  .settings-panel.open { display: block; }
  .creds-saved { font-size: 0.8rem; color: #4caf50; margin-top: 8px; display: none; }
  .card-count { font-size: 0.85rem; color: #888; margin-top: 4px; }
  .setup-box { background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 20px; margin-bottom: 24px; }
  .setup-box p { font-size: 0.85rem; color: #888; margin-bottom: 12px; line-height: 1.5; }
</style>
</head>
<body>
<div class="container">
  <h1>Trello → PDF</h1>
  <p class="subtitle">Pick a board and list, get a clean PDF.</p>

  <div id="setupBox" class="setup-box" style="display:none;">
    <p>Enter your Trello API credentials to get started. You only need to do this once — they'll be saved in your browser.</p>
    <div class="field">
      <label>API Key</label>
      <input type="text" id="apiKey" placeholder="Your Trello API key" />
    </div>
    <div class="field">
      <label>Token</label>
      <input type="text" id="apiToken" placeholder="Your Trello token" />
    </div>
    <button class="btn" onclick="saveAndLoad()">Connect to Trello</button>
    <div class="creds-saved" id="credsSaved">✓ Connected!</div>
  </div>

  <div id="mainUI" style="display:none;">
    <div class="settings-toggle" onclick="toggleSettings()">⚙ Change API credentials</div>
    <div class="settings-panel" id="settingsPanel">
      <div class="field">
        <label>API Key</label>
        <input type="text" id="apiKey2" placeholder="Your Trello API key" />
      </div>
      <div class="field">
        <label>Token</label>
        <input type="text" id="apiToken2" placeholder="Your Trello token" />
      </div>
      <button class="btn btn-secondary" onclick="updateCredentials()">Update & Reload</button>
    </div>

    <div class="field">
      <label>Board</label>
      <select id="boardSelect" onchange="loadLists()">
        <option value="">Loading boards...</option>
      </select>
    </div>

    <div class="field">
      <label>List</label>
      <select id="listSelect" disabled onchange="loadCardCount()">
        <option value="">Select a board first</option>
      </select>
      <div class="card-count" id="cardCount"></div>
    </div>

    <button class="btn" id="exportBtn" onclick="exportPDF()" disabled>Generate PDF</button>

    <div class="progress" id="progress">
      <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
      <div class="progress-text" id="progressText"></div>
    </div>

    <div class="status" id="status"></div>
  </div>
</div>

<script>
const { jsPDF } = window.jspdf;

let API_KEY = '';
let API_TOKEN = '';

function getStoredKey() { return localStorage.getItem('trello_pdf_key') || ''; }
function getStoredToken() { return localStorage.getItem('trello_pdf_token') || ''; }

function apiUrl(path, params = {}) {
  const qs = new URLSearchParams({ key: API_KEY, token: API_TOKEN, ...params }).toString();
  return 'https://api.trello.com/1' + path + '?' + qs;
}

async function apiFetch(path, params = {}) {
  const res = await fetch(apiUrl(path, params));
  if (!res.ok) throw new Error('API error: ' + res.status);
  return res.json();
}

// --- Init ---
window.addEventListener('DOMContentLoaded', () => {
  API_KEY = getStoredKey();
  API_TOKEN = getStoredToken();

  if (API_KEY && API_TOKEN) {
    showMainUI();
    loadBoards();
  } else {
    showSetup();
  }
});

function showSetup() {
  document.getElementById('setupBox').style.display = 'block';
  document.getElementById('mainUI').style.display = 'none';
}

function showMainUI() {
  document.getElementById('setupBox').style.display = 'none';
  document.getElementById('mainUI').style.display = 'block';
  document.getElementById('apiKey2').value = API_KEY;
  document.getElementById('apiToken2').value = API_TOKEN;
}

function saveAndLoad() {
  const key = document.getElementById('apiKey').value.trim();
  const token = document.getElementById('apiToken').value.trim();
  if (!key || !token) return;
  localStorage.setItem('trello_pdf_key', key);
  localStorage.setItem('trello_pdf_token', token);
  API_KEY = key;
  API_TOKEN = token;
  document.getElementById('credsSaved').style.display = 'block';
  setTimeout(() => {
    showMainUI();
    loadBoards();
  }, 500);
}

function updateCredentials() {
  const key = document.getElementById('apiKey2').value.trim();
  const token = document.getElementById('apiToken2').value.trim();
  if (!key || !token) return;
  localStorage.setItem('trello_pdf_key', key);
  localStorage.setItem('trello_pdf_token', token);
  API_KEY = key;
  API_TOKEN = token;
  toggleSettings();
  loadBoards();
}

function toggleSettings() {
  document.getElementById('settingsPanel').classList.toggle('open');
}

// --- Load Data ---
async function loadBoards() {
  const sel = document.getElementById('boardSelect');
  sel.innerHTML = '<option value="">Loading boards...</option>';
  try {
    const boards = await apiFetch('/members/me/boards', { fields: 'name', filter: 'open' });
    boards.sort((a, b) => a.name.localeCompare(b.name));
    sel.innerHTML = '<option value="">— Choose a board —</option>';
    boards.forEach(b => {
      const opt = document.createElement('option');
      opt.value = b.id;
      opt.textContent = b.name;
      sel.appendChild(opt);
    });
  } catch (e) {
    setStatus('error', 'Failed to load boards. Check your API key and token.');
  }
}

async function loadLists() {
  const boardId = document.getElementById('boardSelect').value;
  const listSel = document.getElementById('listSelect');
  const btn = document.getElementById('exportBtn');
  document.getElementById('cardCount').textContent = '';

  if (!boardId) {
    listSel.innerHTML = '<option value="">Select a board first</option>';
    listSel.disabled = true;
    btn.disabled = true;
    return;
  }

  listSel.innerHTML = '<option value="">Loading lists...</option>';
  try {
    const lists = await apiFetch('/boards/' + boardId + '/lists', { filter: 'open' });
    listSel.innerHTML = '<option value="">— Choose a list —</option>';
    lists.forEach(l => {
      const opt = document.createElement('option');
      opt.value = l.id;
      opt.textContent = l.name;
      listSel.appendChild(opt);
    });
    listSel.disabled = false;
  } catch (e) {
    setStatus('error', 'Failed to load lists.');
  }
}

async function loadCardCount() {
  const listId = document.getElementById('listSelect').value;
  const btn = document.getElementById('exportBtn');
  const countEl = document.getElementById('cardCount');

  if (!listId) { btn.disabled = true; countEl.textContent = ''; return; }

  try {
    const cards = await apiFetch('/lists/' + listId + '/cards', { fields: 'name', limit: 1000 });
    countEl.textContent = cards.length + ' card' + (cards.length !== 1 ? 's' : '') + ' in this list';
    btn.disabled = false;
  } catch (e) {
    countEl.textContent = '';
    btn.disabled = false;
  }
}

// --- Image helpers ---
async function loadImageAsDataUrl(url, cardId, attId) {
  // Strategy 1: Try the direct URL with auth params
  try {
    const separator = url.includes('?') ? '&' : '?';
    const authUrl = url + separator + 'key=' + API_KEY + '&token=' + API_TOKEN;
    const res = await fetch(authUrl, { redirect: 'follow' });
    if (res.ok) {
      const blob = await res.blob();
      if (blob.size > 0) return await blobToDataUrl(blob);
    }
  } catch (e) { /* try next strategy */ }

  // Strategy 2: Use the Trello API attachment download endpoint
  if (cardId && attId) {
    try {
      const apiDownloadUrl = 'https://api.trello.com/1/cards/' + cardId + '/attachments/' + attId + '/download?key=' + API_KEY + '&token=' + API_TOKEN;
      const res = await fetch(apiDownloadUrl, { redirect: 'follow' });
      if (res.ok) {
        const blob = await res.blob();
        if (blob.size > 0) return await blobToDataUrl(blob);
      }
    } catch (e) { /* try next strategy */ }
  }

  // Strategy 3: Use attachment data from API which may include base64
  if (cardId && attId) {
    try {
      const metaUrl = 'https://api.trello.com/1/cards/' + cardId + '/attachments/' + attId + '?key=' + API_KEY + '&token=' + API_TOKEN + '&fields=url,previews';
      const res = await fetch(metaUrl);
      if (res.ok) {
        const data = await res.json();
        // Try preview URLs (these are often on S3 and may not need auth)
        if (data.previews && data.previews.length > 0) {
          const preview = data.previews.find(p => p.width >= 300) || data.previews[data.previews.length - 1];
          if (preview && preview.url) {
            try {
              const pRes = await fetch(preview.url);
              if (pRes.ok) {
                const blob = await pRes.blob();
                if (blob.size > 0) return await blobToDataUrl(blob);
              }
            } catch (e) { /* give up */ }
          }
        }
      }
    } catch (e) { /* give up */ }
  }

  return null;
}

function blobToDataUrl(blob) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => resolve(null);
    reader.readAsDataURL(blob);
  });
}

function getResizedDataUrl(dataUrl, maxW, maxH) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      let w = img.naturalWidth, h = img.naturalHeight;
      const ratio = Math.min(maxW / w, maxH / h, 1);
      w = Math.round(w * ratio);
      h = Math.round(h * ratio);
      canvas.width = w;
      canvas.height = h;
      canvas.getContext('2d').drawImage(img, 0, 0, w, h);
      resolve({ dataUrl: canvas.toDataURL('image/jpeg', 0.85), width: w, height: h });
    };
    img.onerror = () => resolve(null);
    img.src = dataUrl;
  });
}

function drawNoImage(doc, cx, cy) {
  doc.setFillColor(36, 36, 36);
  doc.roundedRect(cx - 30, cy - 18, 60, 36, 2, 2, 'F');
  doc.setTextColor(100, 100, 100);
  doc.setFontSize(9);
  doc.setFont('helvetica', 'normal');
  doc.text('No Image', cx, cy + 3, { align: 'center' });
}

// --- PDF Export ---
async function exportPDF() {
  const listId = document.getElementById('listSelect').value;
  if (!listId) return;

  const listName = document.getElementById('listSelect').selectedOptions[0].textContent;
  const boardName = document.getElementById('boardSelect').selectedOptions[0].textContent;
  const btn = document.getElementById('exportBtn');

  btn.disabled = true;
  btn.textContent = 'Working...';
  setStatus('info', 'Fetching cards...');
  showProgress(0, 'Fetching card data...');

  try {
    const cards = await apiFetch('/lists/' + listId + '/cards', {
      fields: 'name,desc,id',
      attachments: 'true',
      attachment_fields: 'url,mimeType,name,id',
      limit: 1000
    });

    if (cards.length === 0) {
      setStatus('error', 'No cards found in this list.');
      btn.disabled = false;
      btn.textContent = 'Generate PDF';
      hideProgress();
      return;
    }

    showProgress(5, 'Found ' + cards.length + ' cards. Loading images...');

    const cardData = cards.map(card => {
      let imgUrl = null;
      let attId = null;
      if (card.attachments && card.attachments.length > 0) {
        const imgAtt = card.attachments.find(a => a.mimeType && a.mimeType.startsWith('image/'));
        if (imgAtt) {
          imgUrl = imgAtt.url;
          attId = imgAtt.id;
        }
      }
      return { name: card.name || 'Untitled', desc: card.desc || '', imgUrl, cardId: card.id, attId };
    });

    const imgResults = [];
    for (let i = 0; i < cardData.length; i++) {
      showProgress(5 + Math.round((i / cardData.length) * 60), 'Loading image ' + (i + 1) + ' of ' + cardData.length + '...');
      if (cardData[i].imgUrl) {
        imgResults.push(await loadImageAsDataUrl(cardData[i].imgUrl, cardData[i].cardId, cardData[i].attId));
      } else {
        imgResults.push(null);
      }
    }

    showProgress(70, 'Building PDF...');

    const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'letter' });
    const pageW = 215.9, pageH = 279.4, margin = 12, gutter = 10;
    const colW = (pageW - margin * 2 - gutter) / 2;
    const imgMaxW = colW - 8;
    const textPad = 4;

    // Title page
    doc.setFillColor(15, 15, 15);
    doc.rect(0, 0, pageW, pageH, 'F');
    doc.setTextColor(232, 232, 232);
    doc.setFontSize(22);
    doc.setFont('helvetica', 'bold');
    doc.text(boardName, pageW / 2, pageH / 2 - 12, { align: 'center' });
    doc.setFontSize(14);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(136, 136, 136);
    doc.text(listName, pageW / 2, pageH / 2 + 2, { align: 'center' });
    doc.setFontSize(10);
    doc.text(cardData.length + ' items \u00B7 ' + new Date().toLocaleDateString(), pageW / 2, pageH / 2 + 14, { align: 'center' });

    const cardsPerPage = 2;

    for (let i = 0; i < cardData.length; i += cardsPerPage) {
      doc.addPage();
      doc.setFillColor(15, 15, 15);
      doc.rect(0, 0, pageW, pageH, 'F');

      showProgress(70 + Math.round((i / cardData.length) * 28), 'Rendering card ' + (i + 1) + ' of ' + cardData.length + '...');

      for (let j = 0; j < cardsPerPage && (i + j) < cardData.length; j++) {
        const card = cardData[i + j];
        const img = imgResults[i + j];
        const x = j === 0 ? margin : margin + colW + gutter;
        const y = margin;
        const ch = pageH - margin * 2;

        // Card bg
        doc.setFillColor(26, 26, 26);
        doc.roundedRect(x, y, colW, ch, 3, 3, 'F');

        // Image area
        const imgAreaY = y + textPad;
        const imgAreaH = ch * 0.55;
        const imgAreaCX = x + colW / 2;
        const imgAreaCY = imgAreaY + imgAreaH / 2;

        if (img) {
          const maxPxW = imgMaxW * 3.78, maxPxH = imgAreaH * 3.78;
          const resized = await getResizedDataUrl(img, maxPxW, maxPxH);
          if (resized) {
            const drawW = resized.width / 3.78, drawH = resized.height / 3.78;
            try {
              doc.addImage(resized.dataUrl, 'JPEG', imgAreaCX - drawW / 2, imgAreaCY - drawH / 2, drawW, drawH);
            } catch (e) {
              drawNoImage(doc, imgAreaCX, imgAreaCY);
            }
          } else {
            drawNoImage(doc, imgAreaCX, imgAreaCY);
          }
        } else {
          drawNoImage(doc, imgAreaCX, imgAreaCY);
        }

        // Divider
        const divY = imgAreaY + imgAreaH + 4;
        doc.setDrawColor(51, 51, 51);
        doc.setLineWidth(0.3);
        doc.line(x + textPad, divY, x + colW - textPad, divY);

        // Name
        const textY = divY + 8;
        doc.setTextColor(232, 232, 232);
        doc.setFontSize(11);
        doc.setFont('helvetica', 'bold');
        const nameLines = doc.splitTextToSize(card.name, colW - textPad * 2);
        doc.text(nameLines.slice(0, 3), x + textPad, textY);
        const nameEndY = textY + Math.min(nameLines.length, 3) * 5;

        // Description
        if (card.desc) {
          doc.setTextColor(170, 170, 170);
          doc.setFontSize(9);
          doc.setFont('helvetica', 'normal');
          const maxDescLines = Math.floor(((y + ch - textPad) - (nameEndY + 4)) / 4);
          const descLines = doc.splitTextToSize(card.desc, colW - textPad * 2);
          doc.text(descLines.slice(0, Math.max(maxDescLines, 3)), x + textPad, nameEndY + 4);
        }
      }

      // Page number
      doc.setTextColor(80, 80, 80);
      doc.setFontSize(8);
      doc.text(String(Math.floor(i / cardsPerPage) + 1), pageW / 2, pageH - 5, { align: 'center' });
    }

    showProgress(100, 'Done!');
    doc.save(boardName + ' - ' + listName + '.pdf');
    setStatus('success', '\u2713 PDF saved: ' + boardName + ' - ' + listName + '.pdf');

  } catch (e) {
    console.error(e);
    setStatus('error', 'Error: ' + e.message);
  }

  btn.disabled = false;
  btn.textContent = 'Generate PDF';
}

// --- UI Helpers ---
function setStatus(type, msg) {
  const el = document.getElementById('status');
  el.className = 'status ' + type;
  el.textContent = msg;
}

function showProgress(pct, text) {
  document.getElementById('progress').classList.add('visible');
  document.getElementById('progressFill').style.width = pct + '%';
  document.getElementById('progressText').textContent = text;
}

function hideProgress() {
  document.getElementById('progress').classList.remove('visible');
}
</script>
</body>
</html>
